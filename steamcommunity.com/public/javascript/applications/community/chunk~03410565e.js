/**** (c) Valve Corporation. Use is governed by the terms of the Steam Subscriber Agreement http://store.steampowered.com/subscriber_agreement/.
 ****/
(self.webpackChunkcommunity = self.webpackChunkcommunity || []).push([
  [657],
  {
    76048: (e) => {
      e.exports = {
        QAFullPageView: "_3tZpFqpGKrksArepdxSE5j",
        QAName: "_2mOBpH-Q1B2CGYjpyVcZvL",
        QAColumns: "pBgAbPu5S77EkhwULNJMQ",
        QAMainCtn: "hHqRc8tmJX5DmOC_J9OSu",
        QAModeratorColumn: "nfftCsjuFUxqo7oht5ZvS",
        QASplitColumns: "_1CRIgUwMI8-DV8bby3TWQb",
        ModeratorInstructions: "RqtnW1y7dqFHzNYQgEXMn",
        AnsweredSectionHeader: "_3cWpkis2Mqzl8A8xF-a9em",
        InputButton: "_1z1rtA-m0g-2LV2Vt1oofr",
        Reload: "_3LIo4Gupf-bEyoN38m0xLy",
        Reloading: "_1hooLg2kfnpqXDhLgPG6gH",
        SignInButton: "GRHnXc4HVJuz6yC7Gkr5k",
        QAHeader: "_3skHmzAqxcsZBq_tkNXLzN",
        QuestionACK: "_16zhk22TxzqPMUoz7I3WEB",
        Visible: "_2jHMeCl9ijq2--JlPwQ6Fz",
        QATitleRow: "_2qdcmBnuOzyLEABfqaT8qv",
        QATitle: "_1c7nCnSMqU4Ukz3wdWSqXF",
        Description: "_3eGNNYyxMkZO39myQDE1XE",
        InputCtn: "oF1kTvqJ3SFh3lHuR5ZHs",
        LogInPrompt: "_3Gbueor3CAgrLqcm5BgjPx",
        ButtonCtn: "_3kFHrlDJDcAvIcJq4lX8lD",
        SaveSpinner: "_20svvC9NhGF5A1hTD-y9kJ",
        QuestionsCtn: "_1W6uJMpV-79gv8A662-iKM",
        InsetShadowTopCtn: "ak9JV2IB-GQLWSc_4GpKB",
        InsetShadowTop: "_1C2e4GaJWY9UCfxJeu3Ifp",
        QuestionsHeader: "jUQG923rSCGTIp6iR40rb",
        QuestionsTitle: "_2CYLB3xFHbAEJS6Z-bSlKz",
        QuestionList: "_28dwOiBG4CQlQcXClFrN9K",
        NoQuestions: "_1R9HBMmOpYYYhZwQh1m5U1",
        Question: "_3BIOouufQgR-V7ivTXLZAm",
        Hidden: "_3XPCkzLM8mFswGMcSCywUA",
        QuestionCtn: "_31sLydaeDe38gXM5axlD9O",
        UserAvatar: "_2ojKekaqQWNpGw8G3x8l_r",
        PersonaName: "_3CaA53te3MV1l4rP0TmdB9",
        QuestionText: "_2NuCE315-vCtCSzxcT1qEm",
        QuestionAndVotes: "ChywOlxnWN_3W_lql2DeN",
        QuestionTitle: "_2AXcHkyp6G5iqdDfTZiwAg",
        QuestionStats: "_1DzgV6zsHS23fEBSvckX88",
        PostTime: "_2hfBugBzm8yU7a82qW2cHx",
        Votes: "_2IyuQJGwbrnTb3a7m8KsZ9",
        Vote_Ready: "_3_8_aVxn-PwduHvKlx36tI",
        Vote_Positive: "eWDCyQ-vvgH6BcvF4_o_e",
        RateIcon: "_2j0GwqqS7RK_-mNPfvuX0f",
        Vote_CannotVote: "_2Pq4zAswQX0s4q5BmDOcoK",
        DateAndTime: "_4VjnZ9DL9exM7YcbLbSh",
        Answer: "wNABP6_Qx7yRFrLkXK41M",
        AnswerTitle: "_1c4moP5DV4s2TT8XzHbSDw",
        AnswerCheck: "u8uV8ZaFofO6c9D42VGY2",
        AnswerText: "_3ar8cNQn3f1-OIjiWPPitA",
        ModerationHeader: "_37OKcYRfuIkylm4nu1umCb",
        ModeratorSection: "_3tP54OFg61u8qq9vrI1GA2",
        ToolRow: "_2c2voljR8QU6ly18xBe9Zx",
        ToolLabel: "_3prTNENecqxmB7UBSWgUyl",
        QADashboardCtn: "_32zJGAGkfjaRrwwUDmbx_Y",
        DashboardHeader: "_1R1EmLdoSBJK82hy_FSG9G",
        DashboardHeaderTitle: "_1cRHaKXhGTjxUnsyLMS0IW",
        DashboardHeaderButtonCtn: "uoLDQx7BVP24M7CtMdUVy",
        DashboardRow: "gpraRkr_GCHPzeFW5wUm7",
        GIDSession: "_3d_6fxEUu5QKFk1X6BmmdU",
        QuestionCount: "_3kZ9Sdx0fxIPNbawZ-iPRU",
        QAndADeleteColumn: "_363MyYnsIHR3suqCkDJb1a",
        QAndAName: "_2-5V8wZPsLM9riXorBMJ1F",
        Prompt: "_2ZFvNUfdh3b32ljUOOm1NB",
        Editing: "_1wUKv_abvHzqvyJg-4E_04",
        NameInput: "_3avr0gEWefqtJlQehAE4CH",
        DeleteButton: "o8aBaeNMu_AdleoGeHA_Z",
        DashboardColumnHeaders: "_2WOM0O_ir8k-lcFjHONR4_",
        CreateQAndADialog: "_1wBzuya0z43LtB3hBPU90I",
        DeleteQAndADialog: "_3valPN89TuPANLrExHyKuc",
        DeleteInfo: "_3EhGHfB3z9uPkO3ZTnwUVm",
      };
    },
    58632: (e) => {
      "use strict";
      var t,
        n = (function () {
          function e(e, t) {
            if ("function" != typeof e)
              throw new TypeError(
                "DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: " +
                  e +
                  ".",
              );
            (this._batchLoadFn = e),
              (this._maxBatchSize = (function (e) {
                var t = !e || !1 !== e.batch;
                if (!t) return 1;
                var n = e && e.maxBatchSize;
                if (void 0 === n) return 1 / 0;
                if ("number" != typeof n || n < 1)
                  throw new TypeError(
                    "maxBatchSize must be a positive number: " + n,
                  );
                return n;
              })(t)),
              (this._batchScheduleFn = (function (e) {
                var t = e && e.batchScheduleFn;
                if (void 0 === t) return s;
                if ("function" != typeof t)
                  throw new TypeError(
                    "batchScheduleFn must be a function: " + t,
                  );
                return t;
              })(t)),
              (this._cacheKeyFn = (function (e) {
                var t = e && e.cacheKeyFn;
                if (void 0 === t)
                  return function (e) {
                    return e;
                  };
                if ("function" != typeof t)
                  throw new TypeError("cacheKeyFn must be a function: " + t);
                return t;
              })(t)),
              (this._cacheMap = (function (e) {
                var t = !e || !1 !== e.cache;
                if (!t) return null;
                var n = e && e.cacheMap;
                if (void 0 === n) return new Map();
                if (null !== n) {
                  var s = ["get", "set", "delete", "clear"].filter(
                    function (e) {
                      return n && "function" != typeof n[e];
                    },
                  );
                  if (0 !== s.length)
                    throw new TypeError(
                      "Custom cacheMap missing methods: " + s.join(", "),
                    );
                }
                return n;
              })(t)),
              (this._batch = null),
              (this.name = (function (e) {
                if (e && e.name) return e.name;
                return null;
              })(t));
          }
          var t = e.prototype;
          return (
            (t.load = function (e) {
              if (null == e)
                throw new TypeError(
                  "The loader.load() function must be called with a value, but got: " +
                    String(e) +
                    ".",
                );
              var t = (function (e) {
                  var t = e._batch;
                  if (
                    null !== t &&
                    !t.hasDispatched &&
                    t.keys.length < e._maxBatchSize
                  )
                    return t;
                  var n = { hasDispatched: !1, keys: [], callbacks: [] };
                  return (
                    (e._batch = n),
                    e._batchScheduleFn(function () {
                      !(function (e, t) {
                        if (((t.hasDispatched = !0), 0 === t.keys.length))
                          return void o(t);
                        var n;
                        try {
                          n = e._batchLoadFn(t.keys);
                        } catch (n) {
                          return a(
                            e,
                            t,
                            new TypeError(
                              "DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: " +
                                String(n) +
                                ".",
                            ),
                          );
                        }
                        if (!n || "function" != typeof n.then)
                          return a(
                            e,
                            t,
                            new TypeError(
                              "DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: " +
                                String(n) +
                                ".",
                            ),
                          );
                        n.then(function (e) {
                          if (!i(e))
                            throw new TypeError(
                              "DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: " +
                                String(e) +
                                ".",
                            );
                          if (e.length !== t.keys.length)
                            throw new TypeError(
                              "DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.\n\nKeys:\n" +
                                String(t.keys) +
                                "\n\nValues:\n" +
                                String(e),
                            );
                          o(t);
                          for (var n = 0; n < t.callbacks.length; n++) {
                            var s = e[n];
                            s instanceof Error
                              ? t.callbacks[n].reject(s)
                              : t.callbacks[n].resolve(s);
                          }
                        }).catch(function (n) {
                          a(e, t, n);
                        });
                      })(e, n);
                    }),
                    n
                  );
                })(this),
                n = this._cacheMap,
                s = this._cacheKeyFn(e);
              if (n) {
                var r = n.get(s);
                if (r) {
                  var l = t.cacheHits || (t.cacheHits = []);
                  return new Promise(function (e) {
                    l.push(function () {
                      e(r);
                    });
                  });
                }
              }
              t.keys.push(e);
              var u = new Promise(function (e, n) {
                t.callbacks.push({ resolve: e, reject: n });
              });
              return n && n.set(s, u), u;
            }),
            (t.loadMany = function (e) {
              if (!i(e))
                throw new TypeError(
                  "The loader.loadMany() function must be called with Array<key> but got: " +
                    e +
                    ".",
                );
              for (var t = [], n = 0; n < e.length; n++)
                t.push(
                  this.load(e[n]).catch(function (e) {
                    return e;
                  }),
                );
              return Promise.all(t);
            }),
            (t.clear = function (e) {
              var t = this._cacheMap;
              if (t) {
                var n = this._cacheKeyFn(e);
                t.delete(n);
              }
              return this;
            }),
            (t.clearAll = function () {
              var e = this._cacheMap;
              return e && e.clear(), this;
            }),
            (t.prime = function (e, t) {
              var n = this._cacheMap;
              if (n) {
                var s,
                  a = this._cacheKeyFn(e);
                if (void 0 === n.get(a))
                  t instanceof Error
                    ? (s = Promise.reject(t)).catch(function () {})
                    : (s = Promise.resolve(t)),
                    n.set(a, s);
              }
              return this;
            }),
            e
          );
        })(),
        s =
          "object" == typeof process && "function" == typeof process.nextTick
            ? function (e) {
                t || (t = Promise.resolve()),
                  t.then(function () {
                    process.nextTick(e);
                  });
              }
            : "function" == typeof setImmediate
              ? function (e) {
                  setImmediate(e);
                }
              : function (e) {
                  setTimeout(e);
                };
      function a(e, t, n) {
        o(t);
        for (var s = 0; s < t.keys.length; s++)
          e.clear(t.keys[s]), t.callbacks[s].reject(n);
      }
      function o(e) {
        if (e.cacheHits)
          for (var t = 0; t < e.cacheHits.length; t++) e.cacheHits[t]();
      }
      function i(e) {
        return (
          "object" == typeof e &&
          null !== e &&
          "number" == typeof e.length &&
          (0 === e.length ||
            (e.length > 0 &&
              Object.prototype.hasOwnProperty.call(e, e.length - 1)))
        );
      }
      e.exports = n;
    },
    28579: (e, t, n) => {
      "use strict";
      n.d(t, { xh: () => V, AC: () => J, u6: () => Z });
      var s = n(90626),
        a = n(17720),
        o = n(44165),
        i = n(34629),
        r = n(10333),
        l = n(51240),
        u = n(56093),
        c = n(78327);
      const d = [
        "mousemove",
        "keypress",
        "scroll",
        "wheel",
        "focusin",
        "touchstart",
        "touchmove",
      ];
      class m {
        static Get() {
          return m.s_Singleton || (m.s_Singleton = new m()), m.s_Singleton;
        }
        constructor() {
          (this.m_callbackList = new l.lu()),
            (this.m_timer = null),
            (this.m_bAreEventListenersRegistered = !1),
            "dev" == c.TS.WEB_UNIVERSE && (window.g_FidgetStore = this);
        }
        ResetFidgetTimer(e) {
          this.m_timer && window.clearTimeout(this.m_timer);
          this.m_timer = window.setTimeout(() => {
            (this.m_timer = null), this.m_callbackList.Dispatch();
          }, 2e3);
        }
        BIsUserFidgeting() {
          return !!this.m_timer;
        }
        GetCallbackList() {
          return this.m_callbackList;
        }
        BRegisterEventListeners() {
          if (this.m_bAreEventListenersRegistered) return !1;
          const e = window;
          for (const t of d) e.addEventListener(t, this.ResetFidgetTimer);
          return (this.m_bAreEventListenersRegistered = !0), !0;
        }
        BUnregisterEventListeners() {
          if (!this.m_bAreEventListenersRegistered) return !1;
          const e = window;
          for (const t of d) e.removeEventListener(t, this.ResetFidgetTimer);
          return (this.m_bAreEventListenersRegistered = !1), !1;
        }
      }
      function A() {
        s.useEffect(() => {
          const e = m.Get().BRegisterEventListeners();
          return () => {
            e && m.Get().BUnregisterEventListeners();
          };
        }, []);
      }
      (0, i.Cg)([r.o], m.prototype, "ResetFidgetTimer", null);
      var h = n(41735),
        v = n.n(h),
        p = n(4434),
        _ = n(68797);
      class Q {
        static Get() {
          return Q.s_Singleton || (Q.s_Singleton = new Q()), Q.s_Singleton;
        }
        constructor() {
          (this.m_mapQAndASessions = new Map()),
            (this.m_mapQAndAChangeCallbackList = new Map()),
            (this.m_dashboardCallbackList = new l.lu()),
            (this.m_mapQuestions = new Map()),
            (this.m_mapQuestionCallbackList = new Map()),
            (this.m_rgPendingQuestionGIDs = []),
            "dev" == c.TS.WEB_UNIVERSE && (window.g_QAndAStore = this);
        }
        GetQAndACallbackList(e) {
          return (
            this.m_mapQAndAChangeCallbackList.has(e) ||
              this.m_mapQAndAChangeCallbackList.set(e, new l.lu()),
            this.m_mapQAndAChangeCallbackList.get(e)
          );
        }
        GetQuestionCallbackList(e) {
          return (
            this.m_mapQuestionCallbackList.has(e) ||
              this.m_mapQuestionCallbackList.set(e, new l.lu()),
            this.m_mapQuestionCallbackList.get(e)
          );
        }
        GetDashboardCallbackList() {
          return this.m_dashboardCallbackList;
        }
        GetSession(e) {
          return this.m_mapQAndASessions.get(e);
        }
        GetAllSessions() {
          return Array.from(this.m_mapQAndASessions.values());
        }
        GetQuestion(e) {
          return this.m_mapQuestions.get(e);
        }
        async LoadAllSessions(e) {
          var t, n, s, a;
          if (!c.iA.logged_in || !c.TS.SESSIONID) return 15;
          const o =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxgetqandasforgroup",
            i = {};
          let r = null;
          try {
            const n = await v().get(o, {
              params: i,
              cancelToken: null == e ? void 0 : e.token,
            });
            if (
              (console.log(n),
              200 == (null == n ? void 0 : n.status) &&
                1 ==
                  (null === (t = n.data) || void 0 === t
                    ? void 0
                    : t.success) &&
                n.data.qandas)
            ) {
              for (const e of n.data.qandas)
                this.m_mapQAndASessions.set(e.gidSession, e);
              return (
                this.m_dashboardCallbackList.Dispatch(this.GetAllSessions()), 1
              );
            }
            r = { response: n };
          } catch (e) {
            r = e;
          }
          const l = (0, _.H)(r);
          return (
            console.error(
              "Could not load question and answer sessions for group",
              l.strErrorMsg,
              l,
            ),
            null !==
              (a =
                null ===
                  (s =
                    null === (n = null == r ? void 0 : r.response) ||
                    void 0 === n
                      ? void 0
                      : n.data) || void 0 === s
                  ? void 0
                  : s.success) && void 0 !== a
              ? a
              : 2
          );
        }
        async CreateNewSession(e, t) {
          var n, s, a, o;
          if (!c.iA.logged_in || !c.TS.SESSIONID) return 15;
          const i =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxcreateqanda",
            r = new FormData();
          r.append("sessionid", c.TS.SESSIONID), r.append("name", e);
          let l = null;
          try {
            const e = await v().post(i, r, {
              withCredentials: !0,
              cancelToken: null == t ? void 0 : t.token,
            });
            if (
              200 == (null == e ? void 0 : e.status) &&
              1 ==
                (null === (n = e.data) || void 0 === n ? void 0 : n.success) &&
              e.data.qanda
            )
              return (
                this.m_mapQAndASessions.set(
                  e.data.qanda.gidSession,
                  e.data.qanda,
                ),
                this.m_dashboardCallbackList.Dispatch(this.GetAllSessions()),
                1
              );
            l = { response: e };
          } catch (e) {
            l = e;
          }
          const u = (0, _.H)(l);
          return (
            console.error("Could not create Q&A", e, u.strErrorMsg, u),
            null !==
              (o =
                null ===
                  (a =
                    null === (s = null == l ? void 0 : l.response) ||
                    void 0 === s
                      ? void 0
                      : s.data) || void 0 === a
                  ? void 0
                  : a.success) && void 0 !== o
              ? o
              : 2
          );
        }
        async RenameSession(e, t, n) {
          var s, a, o, i;
          if (!c.iA.logged_in || !c.TS.SESSIONID) return 15;
          const r =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxrenameqanda/" +
              e,
            l = new FormData();
          l.append("sessionid", c.TS.SESSIONID), l.append("name", t);
          let u = null;
          try {
            const a = await v().post(r, l, {
              withCredentials: !0,
              cancelToken: null == n ? void 0 : n.token,
            });
            if (
              200 == (null == a ? void 0 : a.status) &&
              1 == (null === (s = a.data) || void 0 === s ? void 0 : s.success)
            )
              return (
                (this.m_mapQAndASessions.get(e).strName = t),
                this.GetQAndACallbackList(e).Dispatch(
                  this.m_mapQAndASessions.get(e),
                ),
                this.m_dashboardCallbackList.Dispatch(this.GetAllSessions()),
                1
              );
            u = { response: a };
          } catch (e) {
            u = e;
          }
          const d = (0, _.H)(u);
          return (
            console.error("Could not rename Q&A", e, t, d.strErrorMsg, d),
            null !==
              (i =
                null ===
                  (o =
                    null === (a = null == u ? void 0 : u.response) ||
                    void 0 === a
                      ? void 0
                      : a.data) || void 0 === o
                  ? void 0
                  : o.success) && void 0 !== i
              ? i
              : 2
          );
        }
        async DeleteSession(e, t) {
          var n, s, a, o;
          if (!c.iA.logged_in || !c.TS.SESSIONID) return 15;
          const i =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxdeleteqanda/" +
              e,
            r = new FormData();
          r.append("sessionid", c.TS.SESSIONID);
          let l = null;
          try {
            const s = await v().post(i, r, {
              withCredentials: !0,
              cancelToken: null == t ? void 0 : t.token,
            });
            if (
              200 == (null == s ? void 0 : s.status) &&
              1 == (null === (n = s.data) || void 0 === n ? void 0 : n.success)
            )
              return (
                this.m_mapQAndASessions.delete(e),
                this.m_dashboardCallbackList.Dispatch(this.GetAllSessions()),
                1
              );
            l = { response: s };
          } catch (e) {
            l = e;
          }
          const u = (0, _.H)(l);
          return (
            console.error("Could not delete Q&A", e, u.strErrorMsg, u),
            null !==
              (o =
                null ===
                  (a =
                    null === (s = null == l ? void 0 : l.response) ||
                    void 0 === s
                      ? void 0
                      : s.data) || void 0 === a
                  ? void 0
                  : a.success) && void 0 !== o
              ? o
              : 2
          );
        }
        async LoadSession(e, t, n) {
          var s, a, o, i, r, l, u, d, m, A;
          const h =
              c.iA.logged_in &&
              (!this.m_mapQAndASessions.has(e) ||
                this.m_mapQAndASessions.get(e).bUserCanModerate ||
                this.m_rgPendingQuestionGIDs.length > 0 ||
                t)
                ? "/ajaxgetqandasessionforuser/"
                : "/ajaxgetqandasession/",
            p = c.TS.COMMUNITY_BASE_URL + "questions/" + c.UF.VANITY_ID + h + e,
            Q = {};
          let g = null;
          try {
            const t = await v().get(p, {
              params: Q,
              cancelToken: null == n ? void 0 : n.token,
            });
            if (
              200 == (null == t ? void 0 : t.status) &&
              1 ==
                (null === (s = t.data) || void 0 === s ? void 0 : s.success) &&
              t.data.qanda &&
              t.data.questions
            ) {
              for (const e of t.data.questions) {
                const t = e.gidQuestion,
                  n =
                    null !==
                      (o =
                        null === (a = this.m_mapQuestions.get(t)) ||
                        void 0 === a
                          ? void 0
                          : a.bUserUpVoted) && void 0 !== o
                      ? o
                      : e.bUserUpVoted,
                  s = { ...e, bUserUpVoted: n };
                this.m_mapQuestions.set(t, s),
                  this.GetQuestionCallbackList(t).Dispatch(s);
              }
              const n =
                  null !==
                    (r =
                      null === (i = this.m_mapQAndASessions.get(e)) ||
                      void 0 === i
                        ? void 0
                        : i.bUserCanModerate) && void 0 !== r
                    ? r
                    : t.data.qanda.bUserCanModerate,
                s =
                  null !==
                    (u =
                      null === (l = this.m_mapQAndASessions.get(e)) ||
                      void 0 === l
                        ? void 0
                        : l.bUserCanAskQuestions) && void 0 !== u
                    ? u
                    : t.data.qanda.bUserCanAskQuestions,
                c = {
                  ...t.data.qanda,
                  bUserCanModerate: n,
                  bUserCanAskQuestions: s,
                };
              return (
                this.m_mapQAndASessions.set(e, c),
                this.GetQAndACallbackList(e).Dispatch(c),
                this.UpdatePendingQuestionList(t.data.qanda.rgQuestionGIDs),
                1
              );
            }
            g = { response: t };
          } catch (e) {
            g = e;
          }
          const S = (0, _.H)(g);
          return (
            console.error("Could not load Q&A", e, S.strErrorMsg, S),
            null !==
              (A =
                null ===
                  (m =
                    null === (d = null == g ? void 0 : g.response) ||
                    void 0 === d
                      ? void 0
                      : d.data) || void 0 === m
                  ? void 0
                  : m.success) && void 0 !== A
              ? A
              : 2
          );
        }
        UpdatePendingQuestionList(e) {
          var t;
          const n = new Set();
          for (const t of e) {
            const e = this.m_mapQuestions.get(t);
            e.posterAccountID == c.iA.accountid &&
              1 == e.eState &&
              n.add(e.gidQuestion);
          }
          if (this.m_rgPendingQuestionGIDs.length > 0) {
            const s = new Set(e);
            for (const e of this.m_rgPendingQuestionGIDs)
              s.has(e) &&
                1 ==
                  (null === (t = this.m_mapQuestions.get(e)) || void 0 === t
                    ? void 0
                    : t.eState) &&
                n.add(e);
          }
          this.m_rgPendingQuestionGIDs = Array.from(n);
        }
        async AskNewQuestion(e, t, n) {
          var s, a, o, i, r;
          if (
            !c.iA.logged_in ||
            !c.TS.SESSIONID ||
            !(null === (s = this.m_mapQAndASessions.get(e)) || void 0 === s
              ? void 0
              : s.bUserCanAskQuestions)
          )
            return 15;
          const l =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxaskquestion/" +
              e,
            u = new FormData();
          u.append("sessionid", c.TS.SESSIONID), u.append("question", t);
          let d = null;
          try {
            const t = await v().post(l, u, {
              withCredentials: !0,
              cancelToken: null == n ? void 0 : n.token,
            });
            if (
              200 == (null == t ? void 0 : t.status) &&
              1 == (null === (a = t.data) || void 0 === a ? void 0 : a.success)
            ) {
              this.m_rgPendingQuestionGIDs.push(t.data.gidQuestion);
              const s = !0;
              return this.LoadSession(e, s, n), 1;
            }
            d = { response: t };
          } catch (e) {
            d = e;
          }
          const m = (0, _.H)(d);
          return (
            console.error("Could not upload question", e, t, m.strErrorMsg, m),
            null !==
              (r =
                null ===
                  (i =
                    null === (o = null == d ? void 0 : d.response) ||
                    void 0 === o
                      ? void 0
                      : o.data) || void 0 === i
                  ? void 0
                  : i.success) && void 0 !== r
              ? r
              : 2
          );
        }
        async ModerateQuestion(e, t, n, s) {
          var a, o, i, r, l;
          if (
            !c.iA.logged_in ||
            !c.TS.SESSIONID ||
            !(null === (a = this.m_mapQAndASessions.get(e)) || void 0 === a
              ? void 0
              : a.bUserCanModerate)
          )
            return 15;
          if (1 != n && 3 != n) return 8;
          if (this.m_mapQuestions.get(t).eState == n) return 1;
          const u =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxmoderatequestion/" +
              e,
            d = new FormData();
          d.append("sessionid", c.TS.SESSIONID),
            d.append("gidquestion", t),
            d.append("action", 1 == n ? "show" : "hide");
          let m = null;
          try {
            const t = await v().post(u, d, {
              withCredentials: !0,
              cancelToken: null == s ? void 0 : s.token,
            });
            if (
              200 == (null == t ? void 0 : t.status) &&
              1 == (null === (o = t.data) || void 0 === o ? void 0 : o.success)
            ) {
              const t = !0;
              return this.LoadSession(e, t, s), 1;
            }
            m = { response: t };
          } catch (e) {
            m = e;
          }
          const A = (0, _.H)(m);
          return (
            console.error(
              "Could not moderate question",
              e,
              t,
              n,
              A.strErrorMsg,
              A,
            ),
            null !==
              (l =
                null ===
                  (r =
                    null === (i = null == m ? void 0 : m.response) ||
                    void 0 === i
                      ? void 0
                      : i.data) || void 0 === r
                  ? void 0
                  : r.success) && void 0 !== l
              ? l
              : 2
          );
        }
        async AnswerQuestion(e, t, n, s) {
          var a, o, i, r, l;
          if (
            !c.iA.logged_in ||
            !c.TS.SESSIONID ||
            !(null === (a = this.m_mapQAndASessions.get(e)) || void 0 === a
              ? void 0
              : a.bUserCanAskQuestions)
          )
            return 15;
          const u =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxanswerquestion/" +
              e,
            d = new FormData();
          d.append("sessionid", c.TS.SESSIONID),
            d.append("gidquestion", t),
            d.append("answer", n);
          let m = null;
          try {
            const t = await v().post(u, d, {
              withCredentials: !0,
              cancelToken: null == s ? void 0 : s.token,
            });
            if (
              200 == (null == t ? void 0 : t.status) &&
              1 == (null === (o = t.data) || void 0 === o ? void 0 : o.success)
            ) {
              const t = !0;
              return this.LoadSession(e, t, s), 1;
            }
            m = { response: t };
          } catch (e) {
            m = e;
          }
          const A = (0, _.H)(m);
          return (
            console.error("Could not upload answer", e, t, n, A.strErrorMsg, A),
            null !==
              (l =
                null ===
                  (r =
                    null === (i = null == m ? void 0 : m.response) ||
                    void 0 === i
                      ? void 0
                      : i.data) || void 0 === r
                  ? void 0
                  : r.success) && void 0 !== l
              ? l
              : 2
          );
        }
        async VoteOnQuestion(e, t, n, s) {
          var a, o, i, r, l;
          if (
            !c.iA.logged_in ||
            !c.TS.SESSIONID ||
            !(null === (a = this.m_mapQAndASessions.get(e)) || void 0 === a
              ? void 0
              : a.bUserCanAskQuestions)
          )
            return 15;
          if (n === this.m_mapQuestions.get(t).bUserUpVoted) return 1;
          let u = this.m_mapQuestions.get(t);
          const d = u.nVoteCount,
            m = d + (n ? 1 : -1);
          (u = { ...u, nVoteCount: m, bUserUpVoted: n }),
            this.m_mapQuestions.set(t, u),
            this.GetQuestionCallbackList(t).Dispatch(u);
          const A =
              c.TS.COMMUNITY_BASE_URL +
              "questions/" +
              c.UF.VANITY_ID +
              "/ajaxvoteforquestion/" +
              e,
            h = new FormData();
          h.append("sessionid", c.TS.SESSIONID),
            h.append("gidquestion", t),
            h.append("up", n ? "1" : "0");
          let p = null;
          try {
            const e = await v().post(A, h, {
              withCredentials: !0,
              cancelToken: null == s ? void 0 : s.token,
            });
            if (
              200 == (null == e ? void 0 : e.status) &&
              1 == (null === (o = e.data) || void 0 === o ? void 0 : o.success)
            )
              return 1;
            p = { response: e };
          } catch (e) {
            p = e;
          }
          (u = { ...u, nVoteCount: d, bUserUpVoted: !n }),
            this.m_mapQuestions.set(t, u),
            this.GetQuestionCallbackList(t).Dispatch(u);
          const Q = (0, _.H)(p);
          return (
            console.error("Could not upload vote", e, t, n, Q.strErrorMsg, Q),
            null !==
              (l =
                null ===
                  (r =
                    null === (i = null == p ? void 0 : p.response) ||
                    void 0 === i
                      ? void 0
                      : i.data) || void 0 === r
                  ? void 0
                  : r.success) && void 0 !== l
              ? l
              : 2
          );
        }
      }
      function g(e) {
        const t = (0, p.m)("useQAndASession"),
          n = s.useCallback(
            async (n) => {
              var s;
              return (
                (null === (s = Q.Get().GetSession(e)) || void 0 === s
                  ? void 0
                  : s.bUserCanAskQuestions) &&
                (await Q.Get().AskNewQuestion(e, n, t))
              );
            },
            [e, t],
          ),
          a = s.useCallback(
            (n, s) => {
              var a;
              return (
                (null === (a = Q.Get().GetSession(e)) || void 0 === a
                  ? void 0
                  : a.bUserCanAskQuestions) &&
                Q.Get().VoteOnQuestion(e, n, s, t)
              );
            },
            [e, t],
          ),
          o = s.useCallback(
            (e) => {
              var t;
              const s = !!e,
                o = null == e ? void 0 : e.strName,
                i = null == e ? void 0 : e.bUserCanModerate,
                r = null == e ? void 0 : e.bUserCanAskQuestions,
                l = [],
                u = [],
                c = [],
                d = [];
              for (const n of null !==
                (t = null == e ? void 0 : e.rgQuestionGIDs) && void 0 !== t
                ? t
                : []) {
                const e = Q.Get().GetQuestion(n);
                switch (null == e ? void 0 : e.eState) {
                  case 1:
                    l.push(n);
                    break;
                  case 2:
                    u.push(n);
                    break;
                  case 0:
                    c.push(n);
                    break;
                  case 3:
                    d.push(n);
                }
              }
              return (
                l.sort(
                  (e, t) =>
                    Q.Get().GetQuestion(t).nVoteCount -
                    Q.Get().GetQuestion(e).nVoteCount,
                ),
                u.sort(
                  (e, t) =>
                    Q.Get().GetQuestion(t).rtAnswerTime -
                    Q.Get().GetQuestion(e).rtAnswerTime,
                ),
                c.sort(
                  (e, t) =>
                    Q.Get().GetQuestion(t).rtPostTime -
                    Q.Get().GetQuestion(e).rtPostTime,
                ),
                d.sort(
                  (e, t) =>
                    Q.Get().GetQuestion(t).rtPostTime -
                    Q.Get().GetQuestion(e).rtPostTime,
                ),
                {
                  bIsLoaded: s,
                  strName: o,
                  bUserCanModerate: i,
                  bUserCanAskQuestions: r,
                  fnAskQuestion: n,
                  fnVoteOnQuestion: a,
                  rgModeratedQuestionGIDs: l,
                  rgAnsweredQuestionGIDs: u,
                  rgNewQuestionGIDs: c,
                  rgHiddenQuestionGIDs: d,
                }
              );
            },
            [n, a],
          ),
          [i, r] = s.useState(() => o(Q.Get().GetSession(e))),
          l = s.useCallback((e) => r(o(e)), [o]);
        return (
          (0, u.hL)(Q.Get().GetQAndACallbackList(e), l),
          s.useEffect(() => {
            i.bIsLoaded || Q.Get().LoadSession(e);
          }, [i.bIsLoaded, e]),
          i
        );
      }
      let S = null;
      function f(e) {
        const t = (0, p.m)("useReloadFunction"),
          [n, a] = s.useState(!1),
          o = s.useCallback(() => {
            a(!0);
            const n = Q.Get().LoadSession(e, !1, t);
            return n.then(() => a(!1)), n;
          }, [e, t]),
          i = (function (e) {
            const t = s.useRef(null),
              n = s.useCallback(() => {
                t.current && (t.current(), (t.current = null));
              }, []);
            return (
              (0, u.hL)(m.Get().GetCallbackList(), n),
              s.useEffect(() => () => {
                t.current = null;
              }),
              s.useCallback(
                (...n) => {
                  m.Get().BIsUserFidgeting()
                    ? (t.current = () => e(...n))
                    : ((t.current = null), e(...n));
                },
                [e],
              )
            );
          })(o);
        return (
          s.useEffect(() => {
            if (S) return () => {};
            return (
              (S = window.setInterval(i, 1e4)), () => window.clearInterval(S)
            );
          }, [i]),
          s.useMemo(() => ({ fnReload: o, bIsReloading: n }), [o, n])
        );
      }
      function w(e) {
        const t = (0, p.m)("useQuestionModeratorActions"),
          n = s.useCallback(
            (n, s) => {
              var a;
              return (
                (null === (a = Q.Get().GetSession(e)) || void 0 === a
                  ? void 0
                  : a.bUserCanModerate) && Q.Get().AnswerQuestion(e, n, s, t)
              );
            },
            [e, t],
          ),
          a = s.useCallback(
            (n, s) => {
              var a;
              return (
                (null === (a = Q.Get().GetSession(e)) || void 0 === a
                  ? void 0
                  : a.bUserCanModerate) && Q.Get().ModerateQuestion(e, n, s, t)
              );
            },
            [e, t],
          );
        return s.useMemo(
          () => ({ fnAnswerQuestion: n, fnModerateQuestion: a }),
          [n, a],
        );
      }
      var C = n(7068),
        E = n(82477),
        b = n(76684),
        N = n(21273),
        k = n(738),
        T = n(12155),
        I = n(22797),
        D = n(32754),
        y = n(48479),
        G = n(52038),
        M = n(61859),
        L = n(41338),
        U = n(14771),
        B = n(76048),
        P = n.n(B),
        q = n(41471);
      function V(e) {
        const t = (function () {
          const [e, t] = s.useState(Q.Get().GetAllSessions());
          return (
            (0, u.hL)(Q.Get().GetDashboardCallbackList(), t),
            s.useEffect(() => {
              0 == e.length && Q.Get().LoadAllSessions();
            }, [e.length]),
            e
          );
        })();
        return s.createElement(
          "div",
          { className: P().QADashboardCtn },
          s.createElement(H, null),
          s.createElement(
            "div",
            {
              className: (0, G.A)(P().DashboardRow, P().DashboardColumnHeaders),
            },
            s.createElement(
              "div",
              { className: P().QAndAName },
              (0, M.we)("#QAndA_Column_Name"),
            ),
            s.createElement(
              "div",
              { className: P().GIDSession },
              (0, M.we)("#QAndA_Column_GID"),
            ),
            s.createElement(
              "div",
              { className: P().QuestionCount },
              (0, M.we)("#QAndA_Column_QuestionCount"),
            ),
            s.createElement(
              "div",
              { className: P().QAndADeleteColumn },
              (0, M.we)("#QAndA_Column_DeleteButtons"),
            ),
          ),
          t.map((e) => s.createElement(x, { key: e.gidSession, qanda: e })),
        );
      }
      function H(e) {
        const t = s.useCallback(
          () =>
            (0, k.mK)(s.createElement(R, null), window, {
              strTitle: (0, M.we)("#QAndA_CreateQAndA_Title"),
            }),
          [],
        );
        return s.createElement(
          "div",
          { className: P().DashboardHeader },
          s.createElement(
            "div",
            { className: P().DashboardHeaderTitle },
            (0, M.we)("#QAndA_Dashboard"),
          ),
          s.createElement(
            "div",
            { className: P().DashboardHeaderButtonCtn },
            s.createElement(
              C.$n,
              { onClick: t },
              (0, M.we)("#QAndA_CreateQAndA_Button"),
            ),
          ),
        );
      }
      const F = 120;
      function R(e) {
        const t = (function () {
            const e = (0, p.m)("useCreateQAndAFn");
            return s.useCallback((t) => Q.Get().CreateNewSession(t, e), [e]);
          })(),
          [n, a] = s.useState("");
        return s.createElement(
          N.o0,
          {
            strTitle: (0, M.we)("#QAndA_CreateQAndA_Title"),
            strDescription: (0, M.we)("#QAndA_CreateQAndA_Instructions"),
            strOKButtonText: (0, M.we)("#Button_Create"),
            onOK: () => t(n),
            bOKDisabled: 0 == n.length,
            closeModal: e.closeModal,
            className: P().CreateQAndADialog,
          },
          s.createElement(C.pd, {
            type: "text",
            className: P().NameInput,
            value: n,
            placeholder: (0, M.we)("#QAndA_EnterNamePrompt"),
            onFocus: (e) => e.target.select(),
            onChange: (e) => a(e.currentTarget.value),
            maxLength: F,
          }),
        );
      }
      function x(e) {
        const { qanda: t } = e,
          n =
            c.TS.COMMUNITY_BASE_URL +
            "questions/" +
            c.UF.VANITY_ID +
            "/view/" +
            t.gidSession,
          a = s.useCallback(
            (e) => {
              e.stopPropagation(),
                e.preventDefault(),
                (0, k.mK)(s.createElement(j, { qanda: t }), window, {
                  strTitle: (0, M.we)("#QAndA_CreateQAndA_Title"),
                });
            },
            [t],
          );
        return s.createElement(
          "a",
          { className: P().DashboardRow, href: n },
          s.createElement(O, { qanda: t }),
          s.createElement("div", { className: P().GIDSession }, t.gidSession),
          s.createElement(
            "div",
            { className: P().QuestionCount },
            t.rgQuestionGIDs.length,
          ),
          s.createElement(
            "div",
            { className: P().QAndADeleteColumn },
            s.createElement(
              "div",
              { className: P().DeleteButton, onClick: a },
              s.createElement(T.lMJ, null),
            ),
          ),
        );
      }
      function O(e) {
        const { qanda: t } = e,
          [n, a] = s.useState(!1),
          [o, i] = s.useState(t.strName),
          r = (function () {
            const e = (0, p.m)("useRenameQAndAFn");
            return s.useCallback((t, n) => Q.Get().RenameSession(t, n, e), [e]);
          })(),
          l =
            t.strName.length > 0
              ? t.strName
              : s.createElement(
                  "span",
                  { className: P().Prompt },
                  (0, M.we)("#QAndA_EnterNamePrompt"),
                ),
          u = s.createElement(
            "div",
            { className: P().NameInput },
            s.createElement(C.pd, {
              type: "text",
              className: P().NameInput,
              value: o,
              placeholder: (0, M.we)("#QAndA_EnterNamePrompt"),
              onFocus: (e) => e.target.select(),
              onChange: (e) => i(e.currentTarget.value),
              maxLength: F,
            }),
            s.createElement(
              C.jn,
              {
                onClick: (e) => {
                  e.stopPropagation(),
                    e.preventDefault(),
                    0 != (0, L.kd)(o, t.strName)
                      ? r(t.gidSession, o).then(() => a(!1))
                      : a(!1);
                },
                className: P().InputButton,
              },
              (0, M.we)("#Button_Save"),
            ),
          );
        return s.createElement(
          "div",
          {
            className: (0, G.A)(P().QAndAName, n && P().Editing),
            onClick: (e) => {
              e.stopPropagation(), e.preventDefault(), n || a(!0);
            },
          },
          n ? u : l,
        );
      }
      function j(e) {
        const { qanda: t } = e,
          n = (function () {
            const e = (0, p.m)("useDeleteQAndAFn");
            return s.useCallback((t) => Q.Get().DeleteSession(t, e), [e]);
          })();
        return s.createElement(
          N.o0,
          {
            strTitle: (0, M.we)("#QAndA_Column_DeleteButtons"),
            strDescription: (0, M.we)("#QAndA_DeleteQAndA_Instructions"),
            onOK: () => n(t.gidSession),
            closeModal: e.closeModal,
            className: P().DeleteQAndADialog,
          },
          s.createElement(
            "div",
            { className: P().DeleteInfo },
            (0, M.we)("#QAndA_Column_Name") + ": " + t.strName,
          ),
          s.createElement(
            "div",
            { className: P().DeleteInfo },
            (0, M.we)("#QAndA_Column_QuestionCount") +
              ": " +
              t.rgQuestionGIDs.length,
          ),
        );
      }
      function K(e) {
        const {
            gidSession: t,
            gidQuestion: n,
            bUserCanModerate: a,
            bUserCanVote: o,
            fnVoteOnQuestion: i,
            rtNow: r,
          } = e,
          [l, c] = (function (e) {
            const [t, n] = s.useState(Q.Get().GetQuestion(e));
            (0, u.hL)(Q.Get().GetQuestionCallbackList(e), n);
            const [a, o] = s.useState(!!t);
            return [t, !!t || a];
          })(n);
        if (!l) return null;
        const d = r - l.rtPostTime,
          m = d < U.Kp.PerDay ? (0, M.Hq)(d) : (0, M._l)(l.rtPostTime),
          A = o ? () => i(n, !l.bUserUpVoted) : null,
          h = o
            ? l.bUserUpVoted
              ? P().Vote_Positive
              : P().Vote_Ready
            : P().Vote_CannotVote,
          v = (0, G.A)(
            P().Question,
            3 == l.eState && P().Hidden,
            1 == l.eState && P().Moderated,
            0 == l.eState && P().Unmoderated,
            2 == l.eState && P().Answered,
          );
        return s.createElement(
          "div",
          { className: v },
          s.createElement(
            "div",
            { className: (0, G.A)(P().QuestionCtn, "questionCtn") },
            s.createElement(z, { accountID: l.posterAccountID }),
            s.createElement(
              "div",
              { className: P().QuestionText },
              s.createElement(
                "div",
                { className: P().QuestionAndVotes },
                s.createElement(
                  "div",
                  { className: P().QuestionTitle },
                  l.strQuestionText,
                ),
                s.createElement(
                  D.he,
                  {
                    toolTipContent:
                      o &&
                      (l.bUserUpVoted
                        ? (0, M.we)("#QAndA_VoteRemoveTooltip")
                        : (0, M.we)("#QAndA_VoteTooltip")),
                  },
                  s.createElement(
                    "div",
                    { className: (0, G.A)(h, P().Votes), onClick: A },
                    s.createElement(T.bfp, { className: P().RateIcon }),
                    s.createElement(
                      "div",
                      { className: P().VoteCount },
                      Number(l.nVoteCount).toLocaleString(),
                    ),
                  ),
                ),
              ),
              s.createElement(
                "div",
                { className: P().QuestionStats },
                s.createElement(
                  "div",
                  { className: P().PostTime },
                  s.createElement(
                    b.gS,
                    {
                      rtFullDate: l.rtPostTime,
                      className: P().PostTime,
                      stylesmodule: P(),
                    },
                    m,
                  ),
                ),
              ),
            ),
          ),
          l.rtAnswerTime && s.createElement(Y, { question: l, rtNow: r }),
          a &&
            s.createElement(X, {
              gidSession: t,
              gidQuestion: n,
              eState: null == l ? void 0 : l.eState,
            }),
        );
      }
      function Y(e) {
        const { question: t, rtNow: n } = e,
          a = t.rtAnswerTime && n - t.rtAnswerTime,
          o =
            t.rtAnswerTime &&
            (a < U.Kp.PerDay ? (0, M.Hq)(a) : (0, M._l)(t.rtAnswerTime));
        return t.strAnswerText
          ? s.createElement(
              "div",
              { className: P().Answer },
              s.createElement(
                "div",
                { className: P().AnswerTitle },
                s.createElement(
                  "div",
                  { className: P().AnswerCheck },
                  s.createElement(T.X4B, { color: "#67c1f5" }),
                ),
                (0, M.we)("#QAndA_ModeratorAnswerTitle"),
              ),
              s.createElement(
                "div",
                { className: P().AnswerText },
                " ",
                t.strAnswerText,
                " ",
              ),
              s.createElement(
                "div",
                { className: P().QuestionStats },
                s.createElement(
                  b.gS,
                  {
                    rtFullDate: t.rtAnswerTime,
                    className: P().PostTime,
                    stylesmodule: P(),
                  },
                  o,
                ),
              ),
            )
          : s.createElement(
              "div",
              { className: P().AnswerTitle },
              s.createElement(
                "div",
                { className: P().AnswerCheck },
                s.createElement(T.X4B, { color: "#67c1f5" }),
              ),
              (0, M.we)("#QAndA_AlreadyAnsweredTitle"),
            );
      }
      function z(e) {
        var t;
        const n = a.b.InitFromAccountID(e.accountID).ConvertTo64BitString(),
          { isLoading: o, data: i } = (0, q.js)(e.accountID);
        return o
          ? null
          : s.createElement(
              "a",
              {
                href: i.GetCommunityProfileURL(),
                className: P().PersonaName,
                "data-miniprofile": "s" + n,
              },
              null !== (t = null == i ? void 0 : i.m_strPlayerName) &&
                void 0 !== t
                ? t
                : n,
            );
      }
      function X(e) {
        const { gidSession: t, gidQuestion: n, eState: a } = e,
          { fnAnswerQuestion: o, fnModerateQuestion: i } = w(t),
          r = 0 == a || 3 == a,
          l = 3 != a,
          u = 1 == a;
        return s.createElement(
          "div",
          { className: P().ModeratorSection },
          (0, M.we)("#QAndA_ModeratorLabel"),
          s.createElement(
            "div",
            { className: P().ToolRow },
            s.createElement(ee, {
              strPrompt: (0, M.we)("#QAndA_AnswerPrompt"),
              fnSubmit: (e) => o(n, e),
            }),
          ),
          s.createElement(
            "div",
            { className: P().ToolRow },
            (0, M.we)("#QAndA_ModeratorOtherOptionsLabel"),
            s.createElement(
              D.he,
              {
                toolTipContent: (0, M.we)("#QAndA_ModerateApproveButton_ttip"),
              },
              s.createElement(
                C.$n,
                {
                  onClick: () => i(n, 1),
                  className: P().InputButton,
                  disabled: !r,
                },
                (0, M.we)("#QAndA_ModerateApproveButton"),
              ),
            ),
            s.createElement(
              D.he,
              { toolTipContent: (0, M.we)("#QAndA_ModerateHideButton_ttip") },
              s.createElement(
                C.$n,
                {
                  onClick: () => i(n, 3),
                  className: P().InputButton,
                  disabled: !l,
                },
                (0, M.we)("#QAndA_ModerateHideButton"),
              ),
            ),
            s.createElement(
              D.he,
              { toolTipContent: (0, M.we)("#QAndA_QuickAnswerButton_ttip") },
              s.createElement(
                C.$n,
                {
                  onClick: () => o(n, ""),
                  className: P().InputButton,
                  disabled: !u,
                },
                (0, M.we)("#QAndA_QuickAnswerButton"),
              ),
            ),
          ),
        );
      }
      function J(e) {
        const { gidSession: t } = e;
        A();
        const { strName: n, bUserCanModerate: a } = g(t);
        return s.createElement(
          "div",
          { className: P().QAFullPageView },
          s.createElement(
            "div",
            { className: P().QAName },
            (0, M.we)("#QAndA_Header") +
              ((null == n ? void 0 : n.length) > 0 ? ": " + n : ""),
          ),
          s.createElement(
            "div",
            { className: P().QAColumns },
            s.createElement(Z, { gidSession: t, bHalfOfFullPage: a }),
            a && s.createElement(W, { gidSession: t }),
          ),
        );
      }
      function W(e) {
        const { gidSession: t } = e,
          {
            bUserCanModerate: n,
            rgNewQuestionGIDs: a,
            rgHiddenQuestionGIDs: i,
          } = g(t),
          r = (0, o.P_)(10);
        return n
          ? s.createElement(
              "div",
              {
                className: (0, G.A)(P().QAModeratorColumn, P().QASplitColumns),
              },
              s.createElement(
                y.qx,
                {
                  title: (0, M.we)("#QAndA_ModeratorViewHeader"),
                  className: P().ModeratorInstructions,
                },
                s.createElement(
                  "div",
                  { className: P().QuestionList },
                  a.map((e) =>
                    s.createElement(K, {
                      key: e,
                      gidSession: t,
                      gidQuestion: e,
                      bUserCanModerate: n,
                      bUserCanVote: !1,
                      rtNow: r,
                    }),
                  ),
                ),
              ),
              s.createElement(
                y.qx,
                {
                  title: (0, M.we)("#QAndA_HiddenQuestionsHeader"),
                  className: P().AnsweredSectionHeader,
                  bStartMinimized: !0,
                },
                s.createElement(
                  "div",
                  { className: P().QuestionList },
                  i.map((e) =>
                    s.createElement(K, {
                      key: e,
                      gidSession: t,
                      gidQuestion: e,
                      bUserCanModerate: n,
                      bUserCanVote: !1,
                      rtNow: r,
                    }),
                  ),
                ),
              ),
            )
          : null;
      }
      function Z(e) {
        const { gidSession: t, bHalfOfFullPage: n } = e;
        A();
        const {
            bIsLoaded: a,
            bUserCanAskQuestions: i,
            bUserCanModerate: r,
            fnAskQuestion: l,
            fnVoteOnQuestion: u,
            rgModeratedQuestionGIDs: c,
            rgAnsweredQuestionGIDs: d,
            rgNewQuestionGIDs: m,
          } = g(t),
          { fnReload: h, bIsReloading: v } = f(t),
          p = (0, o.P_)(10),
          _ = r && n,
          { fnModerateQuestion: Q } = w(t);
        return s.createElement(
          "div",
          { className: (0, G.A)(P().QAMainCtn, n && P().QASplitColumns) },
          s.createElement(
            "div",
            { className: (0, G.A)(P().QAHeader, _ && P().ModerationHeader) },
            s.createElement(
              C.$n,
              {
                onClick: h,
                disabled: !a,
                className: (0, G.A)(
                  P().InputButton,
                  P().Reload,
                  v && P().Reloading,
                ),
              },
              s.createElement(
                "div",
                { className: P().ReloadIcon },
                s.createElement(T.MvQ, null),
              ),
            ),
            _
              ? s.createElement(
                  s.Fragment,
                  null,
                  (0, M.we)("#QAndA_ModeratorLabelHeader"),
                  s.createElement(
                    D.he,
                    {
                      toolTipContent: (0, M.we)(
                        "#QAndA_ModerateHideAllButton_ttip",
                      ),
                    },
                    s.createElement(
                      C.$n,
                      {
                        onClick: async () => {
                          for (const e of [m, c, d])
                            for (const t of e) await Q(t, 3);
                        },
                        className: P().InputButton,
                      },
                      (0, M.we)("#QAndA_ModerateHideAllButton"),
                    ),
                  ),
                )
              : i
                ? s.createElement($, { fnAskQuestion: l })
                : a && s.createElement(te, null),
          ),
          c.length + d.length == 0
            ? s.createElement(
                "div",
                { className: P().NoQuestions },
                (0, M.we)("#QAndA_NoQuestionsYet"),
              )
            : s.createElement(
                "div",
                { className: P().QuestionsCtn },
                s.createElement(
                  "div",
                  { className: P().InsetShadowTopCtn },
                  s.createElement("div", { className: P().InsetShadowTop }),
                ),
                s.createElement(
                  "div",
                  { className: P().QuestionList },
                  a
                    ? c.map((e) =>
                        s.createElement(K, {
                          key: e,
                          gidSession: t,
                          gidQuestion: e,
                          bUserCanModerate: _,
                          bUserCanVote: i,
                          fnVoteOnQuestion: u,
                          rtNow: p,
                        }),
                      )
                    : s.createElement(I.t, { position: "center" }),
                ),
                d.length > 0 &&
                  s.createElement(
                    s.Fragment,
                    null,
                    s.createElement(
                      "div",
                      { className: P().AnsweredSectionHeader },
                      (0, M.we)("#QAndA_AnsweredQuestionsHeader"),
                    ),
                    s.createElement(
                      "div",
                      { className: P().QuestionList },
                      d.map((e) =>
                        s.createElement(K, {
                          key: e,
                          gidSession: t,
                          gidQuestion: e,
                          bUserCanModerate: _,
                          bUserCanVote: i,
                          fnVoteOnQuestion: u,
                          rtNow: p,
                        }),
                      ),
                    ),
                  ),
              ),
        );
      }
      function $(e) {
        const [t, n] = s.useState(!1),
          a = (0, p.m)("QuestionBox");
        return s.createElement(
          s.Fragment,
          null,
          s.createElement(
            "div",
            { className: P().Description },
            (0, M.we)("#QAndA_HeaderDescription"),
          ),
          s.createElement(ee, {
            strPrompt: (0, M.we)("#QAndA_QuestionPrompt"),
            fnSubmit: async (t) => {
              const s = await e.fnAskQuestion(t);
              return (
                1 != s ||
                  a.token.reason ||
                  (n(!0),
                  window.setTimeout(() => {
                    a.token.reason || n(!1);
                  }, 1e3)),
                s
              );
            },
          }),
          s.createElement(
            "div",
            { className: (0, G.A)(P().QuestionACK, t && P().Visible) },
            (0, M.we)("#QAndA_QuestionWasPosted"),
          ),
        );
      }
      function ee(e) {
        const { strPrompt: t, fnSubmit: n } = e,
          [a, o] = s.useState(""),
          [i, r] = s.useState(!1);
        return s.createElement(
          s.Fragment,
          null,
          s.createElement(
            "div",
            { className: P().InputCtn },
            s.createElement(C.pd, {
              type: "text",
              placeholder: t,
              maxLength: 512,
              value: a,
              onChange: (e) => o(e.target.value),
            }),
            s.createElement(
              "div",
              { className: P().ButtonCtn },
              i &&
                s.createElement(
                  "div",
                  { className: P().SaveSpinner },
                  s.createElement(I.t, { size: "small", position: "center" }),
                ),
              s.createElement(
                C.$n,
                {
                  onClick: async () => {
                    r(!0);
                    1 == (await n(a)) && o(""), r(!1);
                  },
                  disabled: i || !a,
                  className: P().InputButton,
                },
                (0, M.we)("#QAndA_SubmitCommentButton"),
              ),
            ),
          ),
        );
      }
      function te(e) {
        return s.createElement(
          "div",
          { className: P().Description },
          s.createElement(
            "div",
            { className: P().LogInPrompt },
            (0, M.we)("#QAndA_LogInPrompt"),
          ),
          !c.iA.logged_in &&
            s.createElement(
              C.$n,
              {
                onClick: E.vg,
                className: (0, G.A)(P().SignInButton, P().InputButton),
              },
              (0, M.we)("#Login_SignIn"),
            ),
        );
      }
    },
  },
]);
